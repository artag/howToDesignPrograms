# Вступление

**Базовый рецепт проектирования функций**:

1. **Анализ задачи и определение данных.**
Определите, какая информация и как должна быть представлена в выбранном
языке программирования.
Сформулируйте определения данных и проиллюстрируйте их примерами.

2. **Сигнатура, описание назначения, заголовок.**
Укажите, какие данные функция принимает и выдает.
Сформулируйте короткий ответ на вопрос: «что вычисляет функция?»
Определите заглушку с соответствующей сигнатурой.

3. **Примеры использования функции.**
Представьте примеры, иллюстрирующие назначение функции.

4. **Создание макета функции.**
Используя определения данных, напишите набросок функции.

5. **Определение функции.**
Заполните недостающие части в макете функции.
Используйте определение назначения и примеры.

6. **Тестирование.**
Переформулируйте примеры в тесты и убедитесь, что функция успешно
выполняет их все. Это поможет обнаружить вкравшиеся ошибки.
Кроме того, тесты дополнят примеры и помогут другим понять определение
функции, если в этом возникнет необходимость, а она всегда возникает
в любой серьезной программе.

# Пролог: как писать программы

Ряд запросов [00_simple.rkt](/src/ch00/00_simple.rkt)

```rkt
> (cos pi)
#i-1.0
```

Ответ `#i-1.0` означает неточное (inexact) число.

Пример лишней скобки (ошибка):

```rkt
> (+ (1) (2))
function call:expected a function after the open parenthesis,
found a number
```

## Арифметика, арифметика...

Функции [01_string.rkt](/src/ch00/01_string.rkt):

- `string-append` - сложение строк
- `string-length` - определение длины строки
- `string->number` - преобразование строки в число

Функции [02_bool.rkt](/src/ch00/02_bool.rkt)

- `and`, `or`, `not` - логические операции
- `>`, `<`, `>=`, `<=` - операции сравнения чисел
- `string=?` - сравнение строк (регистрозависимое)

Функции [03_image.rkt](/src/ch00/03_image.rkt)

- `(require 2htdp/image)` - подключение библиотеки (учебного пакета)
- `image-width` - ширина изображения
- `image-height` - высота изображения
- `circle` - создание круга
- `rectangle` - создание прямоугольника
- `overlay` - наложение фигур друг на друга
- `place-image` - поместить изображение внутрь другого в определенное место
- `empty-scene` - белый прямоугольник ("холст") для рисования

## Входы и выходы

**Определение функции**:

```text
(define (ИмяФункции ИмяВхода) Тело)
```

Язык BSL позволяет использовать в именах любые символы, включая «-» и «.».

**Применение функции**:

```text
(ИмяФункции ВыражениеАргумента)
```

Тело функции выисляет **выход** (результат) функции для определенного входа.

Пример:

```rkt
; Определение функции
; x - вход функции
(define (y x) (*x x))

; Применение функции
(y 2)
```

Пример 1: определение функции возведения числа в квадрат

[04_square.rkt](/src/ch00/04_square.rkt)

Пример 2: анимация перемещения ракеты.
Ракета опустится вниз и исчезнет из окна:
[05_animate_rocket.rkt](/src/ch00/05_animate_rocket.rkt)

Здесь используются функции:

- `(require 2htdp/universe)` - подключение доп. библиотеки (учебного пакета) для функции `animate`

- `animate`:
  - создает новое окно с таймером
  - запускает часы и считает количество тактов от 0 до бесконечности
  - после завершения очередного такта применяет нашу фукцию к порядковому номеру текущего такта
  - отрисовывает изменения в окне

## Множество способов вычисления

**Условное выражение**:

```text
(cond
  [ВыражениеУсловия1 ВыражениеРезультата1]
  [ВыражениеУсловия2 ВыражениеРезультата2]
  ...
  [ВыражениеУсловияN ВыражениеРезультатаN])
```

Условные строки, каждая из которых содержит 2 выражения:

- левое - *условие*
- правое - *результат*

Пример 1: определение знака [06_sign.rkt](/src/ch00/06_sign.rkt)

```rkt
(define (sign x)
  (cond
    [(> x 0) 1]
    [(= x 0) 0]
    [(< x 0) -1]))
```

Если все выражения условий вернут `#false`, то DrRa­cket сообщит об ошибке.

Пример 2: анимация перемещения ракеты 2 версия.
Ракета опустится вниз и на половину своего корпуса уйдет под землю,
после чего остановится:
[07_animate_rocket_v2.rkt](/src/ch00/07_animate_rocket_v2.rkt)

Пример 3: анимация перемещения ракеты 3 версия.
Ракета опустится вниз и остановится над землей:
[08_animate_rocket_v3.rkt](/src/ch00/08_animate_rocket_v3.rkt)

## Одна программа, множество определений

**Задание константы**:

```text
(define Имя Выражение)
```

Пример 1:

```rkt
(define HEIGHT 60)
```

Для определений констант порядок имеет значение, а для определений
функций - нет. Встретив определение константы, DrRa­cket вычисляет выражение
в определении, а затем связывает имя константы с полученным результатом.

Если программа включает множество определений функций, их порядок тоже не имеет значения.

**Рекомендуется**:

- ввести все определения констант
- определения функций порядке убывания их важности

Пример 2: анимация перемещения ракеты 4 и 5 версия.
Определение констант и их использование в коде.
Ракета (точно также, как и в предыдущем примере) опустится вниз и
остановится над землей:

[09_animate_rocket_v4.rkt](/src/ch00/09_animate_rocket_v4.rkt)

Пример 3: анимация перемещения ракеты или НЛО.
Ракета (белый фон) садится на серый помост. НЛО (синий фон) приземляется на край окна:

[10_animate_rocket_ufo.rkt](/src/ch00/10_animate_rocket_ufo.rkt)

## Еще одно определение

Пример: анимация перемещения ракеты 6 (финальная) версия.
Для вычисления положения (высоты) ракеты используется формула (`d(t) = v * t`);

[11_animate_rocket_v6.rkt](/src/ch00/11_animate_rocket_v6.rkt)

Здесь 2 определения функций `picture-of-rocket.v6` и `distance`.
Первая вызывает вторую.

## Компиляция программы "Hello world"

[12_hello_world.rkt](/src/ch00/12_hello_world.rkt)

```rkt
#lang racket/base

(displayln "Hello, World!")
```

Компиляция в `exe` файл:

```rkt
raco exe 01_hello_world.rkt -o hello
```

Можно подключить библиотеку как:

```rkt
#lang racket
```

Но тогда размер `exe` файла будет ~12Mb

### Уменьшение размера `exe` файла

#### 1. Switch to racket/base

The most effective way to shrink a Racket binary is to change your initial language from #lang racket to #lang racket/base.

Более компактно будет, если поключить только базовую часть (размер `exe` сокращается до ~2Mb)

```rkt
#lang racket/base
```

Почему так: `#lang racket` includes many large libraries by default. `racket/base` is much leaner.

Можно по мере надобности подключать только нужные модули: `racket/file`, `racket/list`, ...

#### 2. Use the Demodularizer (raco demod)

The "demod" tool flattens your program into a single module and removes unused code (dead code elimination).

```bash
raco demod 01_hello_world.rkt
raco exe -o hello 01_hello_world_rkt_merged.zo
```

Размер `exe` файла сократился до ~170Kb

#### 3. Externalize Shared Libraries (не пробовал)

By default, `raco exe` may attempt to embed everything.
To keep the `.exe` itself tiny, use the raco distribute workflow.

```bash
raco exe main.rkt
raco distribute dist-folder main.exe
```

Result: This places the core Racket runtime in a shared library folder rather than baking it into the `.exe`.
While the total package size is similar, the main executable becomes very small.

#### 4. Post-Compilation Compression (UPX) (не пробовал)

After creating your `.exe`, you can use external compression tools like UPX (Ultimate Packer for eXecutables).

```bash
upx --best my-app.exe
```

**Caution**: Some Racket users have reported that UPX can occasionally break Racket executables,
so verify the file still runs after packing.
