# Вступление

**Базовый рецепт проектирования функций**:

1. **Анализ задачи и определение данных.**
Определите, какая информация и как должна быть представлена в выбранном
языке программирования.
Сформулируйте определения данных и проиллюстрируйте их примерами.

2. **Сигнатура, описание назначения, заголовок.**
Укажите, какие данные функция принимает и выдает.
Сформулируйте короткий ответ на вопрос: «что вычисляет функция?»
Определите заглушку с соответствующей сигнатурой.

3. **Примеры использования функции.**
Представьте примеры, иллюстрирующие назначение функции.

4. **Создание макета функции.**
Используя определения данных, напишите набросок функции.

5. **Определение функции.**
Заполните недостающие части в макете функции.
Используйте определение назначения и примеры.

6. **Тестирование.**
Переформулируйте примеры в тесты и убедитесь, что функция успешно
выполняет их все. Это поможет обнаружить вкравшиеся ошибки.
Кроме того, тесты дополнят примеры и помогут другим понять определение
функции, если в этом возникнет необходимость, а она всегда возникает
в любой серьезной программе.

# Пролог: как писать программы

Ряд запросов [](/src/ch00/00_simple.rkt)

```rkt
> (cos pi)
#i-1.0
```

Ответ `#i-1.0` означает неточное (inexact) число.

Пример лишней скобки (ошибка):

```rkt
> (+ (1) (2))
function call:expected a function after the open parenthesis,
found a number
```

## Арифметика, арифметика...

## Компиляция программы "Hello world"

[01_hello_world.rkt](/src/ch00/01_hello_world.rkt)

```rkt
#lang racket/base

(displayln "Hello, World!")
```

Компиляция в `exe` файл:

```rkt
raco exe 01_hello_world.rkt -o hello
```

Можно подключить библиотеку как:

```rkt
#lang racket
```

Но тогда размер `exe` файла будет ~12Mb

### Уменьшение размера `exe` файла

#### 1. Switch to racket/base

The most effective way to shrink a Racket binary is to change your initial language from #lang racket to #lang racket/base.

Более компактно будет, если поключить только базовую часть (размер `exe` сокращается до ~2Mb)

```rkt
#lang racket/base
```

Почему так: `#lang racket` includes many large libraries by default. `racket/base` is much leaner.

Можно по мере надобности подключать только нужные модули: `racket/file`, `racket/list`, ...

#### 2. Use the Demodularizer (raco demod)

The "demod" tool flattens your program into a single module and removes unused code (dead code elimination).

```bash
raco demod 01_hello_world.rkt
raco exe -o hello 01_hello_world_rkt_merged.zo
```

Размер `exe` файла сократился до ~170Kb

#### 3. Externalize Shared Libraries (не пробовал)

By default, `raco exe` may attempt to embed everything.
To keep the `.exe` itself tiny, use the raco distribute workflow.

```bash
raco exe main.rkt
raco distribute dist-folder main.exe
```

Result: This places the core Racket runtime in a shared library folder rather than baking it into the `.exe`.
While the total package size is similar, the main executable becomes very small.

#### 4. Post-Compilation Compression (UPX) (не пробовал)

After creating your `.exe`, you can use external compression tools like UPX (Ultimate Packer for eXecutables).

```bash
upx --best my-app.exe
```

**Caution**: Some Racket users have reported that UPX can occasionally break Racket executables,
so verify the file still runs after packing.
